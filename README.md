# Zelo AI — Developer Documentation

## 1. Overview

Zelo AI — приложение для изучения языков.

Оно выглядит так:
Юзер выбирает язык и проходит уровни, где учит слова через карточки. В языке есть 16 тем, и в каждой примерно по 200 слов, разбитых на 11 уровней. В конце каждого уровня можно пообщаться с GPT и сразу погонять все выученные слова на практике.

Меня увлекло учить английский по карточкам, и я решил сделать своё приложение, так как многое было неудобно в других. 

Моя идея в том, чтобы сначала выучить 500+ слов. Так сразу можно говорить и понимать на базовом уровне. Потом, уже зная слова, будет проще учить грамматику. Ведь когда слова уже есть, их нужно только правильно связать.

По архитектуре решил делать на MVVM — мне кажется, это самая удобная архитектура для приложений среднего размера.

Стек: SwiftUI, CoreData, Firebase, Notifications, StoreKit, DeepSeek.
---

## 2. Core Data Models

### Flash\_Card.xcdatamodel

* **Основная сущность:** `FlashCard`

  * **Поля:** `id: UUID`, `front: String`, `back: String`, `level: Int16`, `theme: String`
  * Используется для сохранения прогресса (например, сколько раз повторена карточка)
* Связи и ограничения минимальны, структура прямолинейная, упор на скорость доступа и фильтрацию по теме и уровню.

### Persistence.swift

* **Настройка Core Data Stack:**

  * `persistentContainer` с именем модели
  * `viewContext` для основного потока
* **Методы сохранения:** `saveContext()`
* **Обоснование:** хранение прогресса через Core Data дает нативную поддержку Undo, оптимизацию под SwiftUI и атомарность транзакций

---

## 3. JSON Structure

* **Примеры файлов:** `English A1.json`, `Arabic Course.json`
* **Формат карточки:**

```json
{
  "id": "uuid",
  "front": "apple",
  "back": "яблоко"
}
```

* Каждая тема имеет массив таких карточек (\~200 слов)
* **Преимущество JSON:** легко редактировать курсы вручную, можно подтягивать новые языки без перекомпиляции приложения

---

## 4. Initial Data Setup

### InitialDataSetup.swift

* **Задачи:**

  * Загружает JSON
  * Декодирует в структуры Swift (`[FlashCard]`)
  * Распределяет карточки по 11 уровням
* **Особенности:**

  * Алгоритм равномерного деления массива
  * Фильтрует дубликаты по тексту `front` через кастомный `unique(by:)`
* **Обоснование:**

  * Равномерное распределение помогает выравнивать сложность курса
  * Фильтрация дублей предотвращает баги с повторяющимися словами в разных JSON-файлах

---

## 5. Notes

* Остальные языки в JSON-файлах могут быть не полностью заполнены, но система работает
* Структуры данных минималистичные, чтобы облегчить интеграцию с ViewModels и SwiftUI
* **Основной нестандартный ход:** гибрид Core Data + JSON, что сочетает надежность хранения прогресса и гибкость контента

---

## 6. ViewModels

### AIChatVM

* Отвечает за логику взаимодействия с GPT
* **Основной сценарий:** после прохождения уровня пользователь может начать диалог с AI
* **Методы:**

  * `sendMessage(_:)` — отправка запроса к GPT API и получение ответа
  * `resetChat()` — сброс истории диалога
* **Особенности:**

  * История сообщений хранится локально для сессии
  * Встроена обработка ошибок API и индикаторы загрузки

### AppNavigationVM

* Управляет навигацией между экранами приложения
* **Методы и свойства:**

  * `currentScreen` — текущее отображаемое View
  * `navigate(to:)` — программный переход на другой экран
* **Особенности:**

  * Центральная точка управления навигацией
  * Позволяет отделить бизнес-логику и UI, избегая прямых переходов из Views

### DesignVM

* Хранит единообразные параметры дизайна
* Включает цвета, шрифты, тени, скругления
* Используется всеми Views для консистентного отображения
* **Особенности:**

  * Вынос дизайна в отдельную VM позволяет легко менять стили без правки каждого View

### HomeVM

* Основная бизнес-логика приложения для HomeView
* Отвечает за:

  * Прогресс пользователя по темам и уровням
  * Блокировку уровней (`isLevelUnlocked(themeIndex: Int, level: Int) -> Bool`)
  * Распределение карточек по уровням при загрузке темы
* **Особенности:**

  * Алгоритм динамического открытия уровней
  * Фильтрация повторов карточек
  * Центральная точка для данных HomeView, минимизируя прямой доступ из Views к JSON

### OnboardingVM

* Управляет логикой онбординга (вводного экрана)
* **Методы:**

  * `completeOnboarding()` — сохраняет состояние завершения
  * Проверка, показывать ли экран при следующем запуске
* **Особенности:**

  * Сохраняет состояние в UserDefaults
  * Позволяет плавно отделить вводную логику от основной функциональности приложения

---

## 7. UI Structure — SwiftUI Views

Блок Views отвечает за визуальную оболочку, навигацию и взаимодействие пользователя с данными. Архитектура построена через SwiftUI с привязкой к соответствующим ViewModels.

### Tab Bar

* **Файл:** TabBarElements.swift
* Определяет кастомный TabBar для переключения между основными разделами: Home, Notes, AI Chat, Settings
* Каждый элемент TabBar — кастомная кнопка с иконкой и анимацией при выборе
* Используется @Binding для синхронизации выбранной вкладки с родительским View
* **Особенности:**

  * Кастомная анимация выбора вкладки через withAnimation
  * Поддержка динамических иконок и цветов через DesignVM

### Onboarding

* **Файлы:** OnboardingView\.swift, Screen2.swift, Screen8.swift, Screen9.swift
* Последовательность экранов для первичной настройки пользователя: возраст, уровень языка, мотивация
* OnboardingView — контейнер для свайпов между отдельными экранными компонентами (ScreenX)
* **Особенности:**

  * Сохраняется прогресс онбординга в UserDefaults через отдельную VM или Binding
  * Дизайн адаптирован под разные размеры экранов через GeometryReader
  * Поддержка кастомной анимации перехода между экранами

### Home Section

* **Файлы:** HomeView\.swift, AddCollectionView\.swift
* HomeView — основной экран с темами и уровнями
* Кружки уровней → переход в FlashCardView
* Прогресс отображается через методы HomeVM.isLevelUnlocked
* **Особенности:**

  * Динамическое отображение доступных/заблокированных уровней
  * AddCollectionView позволяет создавать новые коллекции карточек
  * Связь с HomeVM через @ObservedObject, обновление UI в реальном времени

### FlashCard Section

* **Файл:** FlashCardView\.swift
* Экран для изучения слов через карточки
* Поддержка свайпа для переключения слов
* Система оценки “правильно/неправильно” для закрепления материала
* **Особенности:**

  * Swipe-gesture кастомизирован через DragGesture
  * Привязка к FlashCardVM для управления текущей карточкой и прогрессом
  * Адаптивный UI для различных размеров и ориентаций экранов

### AI Chat

* **Файлы:** AIChatView\.swift, ChatView\.swift
* После завершения уровня пользователю предлагается диалог с GPT для закрепления материала
* AIChatView — общий контейнер, ChatView — интерфейс сообщений
* **Особенности:**

  * Интеграция GPT API для генерации диалога
  * Реализована асинхронная загрузка сообщений и обновление UI через Combine
  * Стилизация сообщений и анимация появления текста

### Notes Section

* **Файлы:** NotesView\.swift, AddNoteView\.swift, EditNoteView\.swift
* Позволяет создавать, просматривать и редактировать заметки
* Вся работа с заметками привязана к VM для синхронизации с локальным хранилищем
* **Особенности:**

  * Поддержка текстового ввода с динамическим ростом поля
  * Реализация CRUD через методы VM
  * UI обновляется в реальном времени при изменении данных

### Profile & Settings

* **Файлы:** ProfileView\.swift, SettingsView\.swift
* Настройка профиля пользователя, управления подписками и общих параметров приложения
* **Особенности:**

  * Дизайн унифицирован с помощью DesignVM
  * Используются кастомные компоненты для переключателей и списков
  * Интеграция с UserDefaults и Firebase для сохранения пользовательских настроек

---

## 8. Utilities & Extensions

### 8.1 AutoFocusModifier.swift

* **Тип:** ViewModifier
* **Назначение:** Автоматическое фокусирование на текстовых полях
* **Особенности:** Позволяет управлять клавиатурой через SwiftUI без сложного UIKit-кода

### 8.2 Card+Extensions.swift

* **Тип:** расширение (extension) для структур карточек
* **Назначение:** Добавляет вспомогательные методы для карточек слов, например, проверку правильности ответа, преобразования данных для UI
* **Особенности:** Инкапсулирует логику работы с отдельной карточкой, чтобы основная модель оставалась чистой

### 8.3 Color HEX+.swift

* **Тип:** расширение для UIColor/Color
* **Назначение:** Позволяет создавать цвета из HEX-кодов
* **Обоснование:** Упрощает работу с дизайнерскими палитрами, чтобы не писать RGB вручную

### 8.4 LaunchScreen.storyboard

* **Тип:** стандартный storyboard для экрана запуска
* **Особенности:** Используется минимально, для отображения логотипа при старте приложения

### 8.5 GoogleService-Info.plist

* **Назначение:** Конфигурация Firebase для проекта
* **Особенности:** Хранит ключи и идентификаторы для подключения к Firebase SDK

### 8.6 AppDelegate.swift

* **Тип:** делегат приложения
* **Функции:**

  * Инициализация Firebase
  * Настройка UIWindow и root view controller
  * Обработка жизненного цикла приложения
* **Особенности:** Стандартный UIKit entry point, необходим для корректной интеграции сервисов (Firebase, Push и др.)

---

## 9. JSON и прочие ресурсы

### 1. Основные файлы приложения

* `Anki_Flash_CardsApp.swift` — точка входа приложения, запускает SwiftUI-приложение и инициализирует `HomeView`
* `Anki_Flash_Cards.entitlements` — права приложения, необходимые для работы на iOS
* `Info.plist` — метаинформация о приложении (название, версии, идентификаторы, разрешения)

### 2. JSON-файлы с карточками

* Файлы расположены в `Model/Core Data/Shop Language Json/` и представляют собой отдельные темы с уровнями. Например:

  * `Chinese A1.json`
  * `English A1.json`
  * `Italian A1.json`

#### Структура карточки

```json
{
  "id": "uuid",
  "front": "apple",
  "back": "яблоко"
}
```

* `id` — уникальный идентификатор карточки
* `front` — слово на изучаемом языке
* `back` — перевод или объяснение на русском

#### Особенности работы с данными

* Каждый файл содержит примерно 200 слов
* При загрузке данные распределяются по 11 уровням равномерно
* Для фильтрации дубликатов используется кастомный метод `unique(by:)`, который проверяет текстовые значения даже при разных `id`

### 3. Неиспользуемые файлы

Файлы из папки `Don't use (maybe delete)` не участвуют в текущей версии:

* `CollectionCardView.swift`
* `MoveCardsView.swift`
* `EditSetView.swift`
* `MainSetCardView.swift`

Они могут быть удалены без влияния на функционал

---

## Выводы по ресурсам

* JSON-файлы — единственный источник карточек, все темы и уровни формируются динамически на их основе
* Фильтрация дублей и равномерное распределение по уровням — ключевые решения для стабильной работы приложения
* Структура файлов проста, но гибкая: легко добавлять новые языки или уровни без изменения логики приложения


